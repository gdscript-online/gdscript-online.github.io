class RingBuffer{constructor(a,b,c){this.buffer=a,this.avail=b,this.threads=c,this.rpos=0,this.wpos=0}data_left(){return this.threads?Atomics.load(this.avail,0):this.avail}space_left(){return this.buffer.length-this.data_left()}read(a){const c=this.buffer.length;let d=0,b=a.length;if(this.rpos+b>c){const e=c-this.rpos;a.set(this.buffer.subarray(this.rpos,c)),d=e,b-=e,this.rpos=0}b&&a.set(this.buffer.subarray(this.rpos,this.rpos+b),d),this.rpos+=b,this.threads?(Atomics.add(this.avail,0,-a.length),Atomics.notify(this.avail,0)):this.avail-=a.length}write(b){const a=b.length,c=this.buffer.length-this.wpos;if(c>=a)this.buffer.set(b,this.wpos),this.wpos+=a,c===a&&(this.wpos=0);else{const d=b.subarray(0,c),a=b.subarray(c);this.buffer.set(d,this.wpos),this.buffer.set(a),this.wpos=a.length}this.threads?(Atomics.add(this.avail,0,a),Atomics.notify(this.avail,0)):this.avail+=a}}class GodotProcessor extends AudioWorkletProcessor{constructor(){super(),this.threads=!1,this.running=!0,this.lock=null,this.notifier=null,this.output=null,this.output_buffer=new Float32Array,this.input=null,this.input_buffer=new Float32Array,this.port.onmessage=a=>{const b=a.data.cmd,c=a.data.data;this.parse_message(b,c)}}process_notify(){this.notifier&&(Atomics.add(this.notifier,0,1),Atomics.notify(this.notifier,0))}parse_message(b,a){if(b==='start'&&a){const c=a[0];let b=0;this.threads=!0,this.lock=c.subarray(b,++b),this.notifier=c.subarray(b,++b);const d=c.subarray(b,++b),e=c.subarray(b,++b);this.input=new RingBuffer(a[1],d,!0),this.output=new RingBuffer(a[2],e,!0)}else b==='stop'?(this.running=!1,this.output=null,this.input=null):b==='start_nothreads'?this.output=new RingBuffer(a[0],a[0].length,!1):b==='chunk'&&this.output.write(a)}static array_has_data(a){return a.length&&a[0].length&&a[0][0].length}process(a,b,e){if(!this.running)return!1;if(this.output===null)return!0;const c=GodotProcessor.array_has_data(a);if(c){const b=a[0],c=b[0].length*b.length;this.input_buffer.length!==c&&(this.input_buffer=new Float32Array(c)),this.threads?this.input.space_left()>=c?(GodotProcessor.write_input(this.input_buffer,b),this.input.write(this.input_buffer)):this.port.postMessage('Input buffer is full! Skipping input frame.'):(GodotProcessor.write_input(this.input_buffer,b),this.port.postMessage({cmd:'input',data:this.input_buffer}))}const d=GodotProcessor.array_has_data(b);if(d){const c=b[0],a=c[0].length*c.length;this.output_buffer.length!==a&&(this.output_buffer=new Float32Array(a)),this.output.data_left()>=a?(this.output.read(this.output_buffer),GodotProcessor.write_output(c,this.output_buffer),this.threads||this.port.postMessage({cmd:'read',data:a})):this.port.postMessage('Output buffer has not enough frames! Skipping output frame.')}return this.process_notify(),!0}static write_output(a,c){const b=a.length;for(let d=0;d<b;d++)for(let e=0;e<a[d].length;e++)a[d][e]=c[e*b+d]}static write_input(c,a){const b=a.length;for(let d=0;d<b;d++)for(let e=0;e<a[d].length;e++)c[e*b+d]=a[d][e]}}registerProcessor('godot-processor',GodotProcessor)